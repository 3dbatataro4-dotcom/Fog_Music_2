<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Nocturne - V35.0 Glowing Notes</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Noto+Serif+TC:wght@400;700&display=swap');

        :root {
            --bg-color: #050505;
            --c-perfect: #e6c288;
            --c-great: #D6A7C2;
            --c-good: #96B5D9;
            --c-miss: #757575;
            --c-ss: #bde0fe;
            --master-color: rgba(0,0,0,0);
        }

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: 'Cinzel', serif;
            color: #fff;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            overscroll-behavior: none;
        }

        #bg-layer { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-size: cover; background-position: center;
            filter: blur(4px) brightness(0.4) grayscale(0.2); 
            transition: background-image 0.8s ease-in-out;
            z-index: 0;
        }
        
        #vignette {
            position: fixed; inset: 0; pointer-events: none; z-index: 900;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 100%);
        }

        #master-layer {
            position: fixed; inset: 0; pointer-events: none; z-index: 800;
            background: radial-gradient(circle, transparent 30%, var(--master-color) 90%);
            opacity: 0; transition: opacity 0.5s;
            mix-blend-mode: screen;
        }

        #play-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.2); 
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            z-index: 1;
            overflow: hidden; 
        }

        canvas { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        #input-zone { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; z-index: 100; }

        .screen { 
            position: absolute; inset: 0; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            transition: opacity 0.5s ease; pointer-events: none; z-index: 200;
        }
        
        .active-ui { pointer-events: auto; }
        .hidden { opacity: 0; pointer-events: none !important; }

        /* UI Styles */
        .title-box { margin-bottom: 4vh; text-align: center; transform: translateY(-2vh); }
        h1 { 
            font-family: 'Playfair Display', serif; font-style: italic;
            font-size: 11vh; 
            color: #fff; text-shadow: 0 0 15px var(--c-perfect); 
            margin: 0; font-weight: 700; line-height: 1.0;
        }
        .sub { color: var(--c-perfect); letter-spacing: 0.8em; font-size: 2.2vh; margin-top: 1vh; }

        .carousel-container { 
            width: 100%; height: 45%; 
            display: flex; justify-content: center; align-items: center; 
            perspective: 1000px; transform-style: preserve-3d;
            margin-top: 0; 
        }
        
        .song-card { 
            position: absolute; width: 32vh; aspect-ratio: 1/1; 
            border: 2px solid rgba(255,255,255,0.3); 
            transition: transform 0.4s cubic-bezier(0.165, 0.84, 0.44, 1), opacity 0.4s ease;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); cursor: pointer; background: #000;
            overflow: visible; 
        }
        .card-img-wrap { width: 100%; height: 100%; overflow: hidden; position: relative; }
        .card-img-wrap img { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; filter: grayscale(50%); transition: 0.4s; }
        .song-title-overlay {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(0,0,0,0.85); color: var(--c-perfect);
            font-size: 2.2vh; padding: 1vh 0; font-family: 'Noto Serif TC', serif; font-weight: bold;
            opacity: 0; transition: 0.3s; transform: translateY(100%); text-align: center;
        }

        .rank-row {
            position: absolute; top: -6vh; left: 50%; transform: translateX(-50%);
            display: flex; gap: 1vh; width: 160%; justify-content: center;
            opacity: 0; transition: 0.4s; z-index: 50;
        }
        .rank-item {
            font-family: 'Playfair Display', serif; font-weight: 700; font-size: 4.5vh; 
            width: 1.5em; text-align: center; text-shadow: 0 0 5px currentColor;
        }
        .rank-SS { color: var(--c-ss); text-shadow: 0 0 20px var(--c-ss), 0 0 10px #fff; font-style: italic; }
        .rank-S { color: #ffe600; text-shadow: 0 0 15px #ffe600; }
        .rank-A { color: #a8d8ea; }
        .rank-B { color: #a3d9a5; }
        .rank-C { color: #aaa; }
        .rank-F { color: #777; }
        .rank-none { color: #555; font-weight: 400; text-shadow: none; font-family: sans-serif; font-size: 3vh; line-height: 1.5; }

        .c-center { transform: translateZ(0) scale(1.15); border-color: var(--c-perfect); box-shadow: 0 0 40px rgba(212, 175, 55, 0.4); z-index: 20; }
        .c-center img { opacity: 1; filter: grayscale(0%); }
        .c-center .song-title-overlay { opacity: 1; transform: translateY(0); }
        .c-center .rank-row { opacity: 1; top: -7vh; } 
        
        .c-left { transform: translateX(-120%) scale(0.85) rotateY(25deg); opacity: 0.5; z-index: 10; }
        .c-right { transform: translateX(120%) scale(0.85) rotateY(-25deg); opacity: 0.5; z-index: 10; }
        .c-left .rank-row, .c-right .rank-row { opacity: 0; } 
        .c-hidden-left { transform: translateX(-250%) scale(0.7); opacity: 0; pointer-events: none; }
        .c-hidden-right { transform: translateX(250%) scale(0.7); opacity: 0; pointer-events: none; }

        .diff-group { display: flex; gap: 4vh; margin-top: 3vh; align-items: center; }
        .btn-diff { 
            background: transparent; border: none; color: #888; padding: 1vh 2vw; 
            font-family: 'Cinzel', serif; font-size: 2.8vh; font-weight: bold;
            cursor: pointer; transition: all 0.3s; position: relative; white-space: nowrap;
        }
        .btn-diff:hover { color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.8); }
        .btn-master { color: #d7ccc8; }
        .btn-master:hover { color: #ff8a80; text-shadow: 0 0 20px #ff5252; }

        .settings-group { margin: 2vh 0; display: flex; flex-direction: column; gap: 2.5vh; align-items: center; width: 100%; }
        .setting-row { display: flex; gap: 2vh; align-items: center; color: #ccc; font-size: 3vh; font-family: 'Cinzel'; justify-content: center; width: 100%; }
        .btn-offset { background: rgba(255,255,255,0.1); border: 2px solid #666; color: #fff; width: 7vh; height: 7vh; border-radius: 50%; cursor: pointer; font-size: 3.5vh; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        .btn-offset:hover { background: var(--c-perfect); color: #000; border-color: var(--c-perfect); }

        /* HUD */
        .hud-element { position: absolute; pointer-events: none; }
        #score { top: 2%; right: 4%; font-size: 7vh; font-weight: 600; color: #fff; font-family: 'Playfair Display'; font-style: italic; opacity: 0.95; }
        #combo-container { top: 30%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; }
        #combo { font-size: 25vh; line-height: 1; color: rgba(255,255,255,0.12); font-family: 'Playfair Display'; transition: transform 0.05s; }
        #combo.bump { transform: scale(1.1); color: rgba(255,255,255,0.25); }
        #judge-container { top: 60%; left: 50%; transform: translate(-50%, -50%); height: 12vh; display: flex; justify-content: center; align-items: center; width: 100%; }
        .judge-text { font-size: 8vh; letter-spacing: 0.1em; font-weight: 800; opacity: 0; text-shadow: 0 0 25px rgba(0,0,0,0.9); white-space: nowrap; }
        
        @keyframes popFade { 0% { opacity: 0; transform: scale(0.8) translateY(2vh); } 20% { opacity: 1; transform: scale(1.15) translateY(-1vh); } 100% { opacity: 0; transform: scale(1.0) translateY(-3vh); } }
        .anim-judge { animation: popFade 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }

        .pause-icon { 
            position: absolute; top: 2%; left: 4%; width: 8vh; height: 8vh; 
            color: #aaa; font-size: 4vh; cursor: pointer; z-index: 201; transition: 0.3s;
            display: flex; justify-content: center; align-items: center;
            border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; background: rgba(0,0,0,0.4);
        }
        .pause-icon:hover { color: #fff; border-color: var(--c-perfect); background: rgba(255,255,255,0.2); }

        .modal { background: rgba(10,12,15,0.95); border: 2px solid var(--c-perfect); padding: 5vh 5vw; text-align: center; box-shadow: 0 0 60px rgba(0,0,0,0.9); backdrop-filter: blur(15px); min-width: 70%; }
        .btn-modal { display: block; width: 100%; margin: 2.5vh 0; padding: 2vh; background: transparent; border: 1px solid #666; color: #ccc; font-family: 'Cinzel'; cursor: pointer; transition: 0.3s; font-size: 3vh; font-weight: bold; }
        .btn-modal:hover { border-color: var(--c-perfect); color: var(--c-perfect); background: rgba(230, 194, 136, 0.1); }

        #countdown { position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; font-size: 30vh; color: var(--c-perfect); z-index: 150; pointer-events: none; opacity: 0; font-family: 'Playfair Display'; font-style: italic;}

        #orientation-lock { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        #orientation-lock .icon { font-size: 4rem; animation: rotate-phone 2s infinite ease-in-out; }
        @keyframes rotate-phone { 0%, 100% { transform: rotate(0deg); } 50% { transform: rotate(-90deg); } }
        @media screen and (orientation: portrait) { #orientation-lock { display: flex; } #app { opacity: 0; pointer-events: none; } }

        /* Custom Range Slider */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 0.5vh; cursor: pointer; background: rgba(255,255,255,0.3); border-radius: 1vh; }
        input[type=range]::-webkit-slider-thumb { height: 4vh; width: 4vh; border-radius: 50%; background: var(--c-perfect); cursor: pointer; -webkit-appearance: none; margin-top: -1.75vh; box-shadow: 0 0 10px var(--c-perfect); }
        input[type=range]::-moz-range-track { width: 100%; height: 0.5vh; cursor: pointer; background: rgba(255,255,255,0.3); border-radius: 1vh; }
        input[type=range]::-moz-range-thumb { height: 4vh; width: 4vh; border: none; border-radius: 50%; background: var(--c-perfect); cursor: pointer; box-shadow: 0 0 10px var(--c-perfect); }
    </style>
</head>
<body>

<div id="orientation-lock">
    <div class="icon">⟳</div>
    <h2 style="color:#e6c288; margin: 20px 0;">請旋轉裝置</h2>
    <p style="color:#888;">本遊戲僅支援橫式遊玩</p>
</div>

<div id="bg-layer"></div>
<div id="vignette"></div>
<div id="master-layer"></div>

<div id="play-container">
    <canvas id="game"></canvas>
    <div id="input-zone"></div>
    <div class="pause-icon" onclick="pauseGame()">||</div>

    <div id="screen-hud" class="screen hidden">
        <div id="score" class="hud-element">000000</div>
        <div id="combo-container" class="hud-element"><div id="combo"></div></div>
        <div id="judge-container" class="hud-element"><div id="judge" class="judge-text"></div></div>
    </div>

    <div id="screen-home" class="screen active-ui">
        <div class="title-box">
            <h1>Nocturne</h1>
            <div class="sub">OF THE FOG</div>
        </div>
        <div class="carousel-container" id="carousel"></div>
        <div class="diff-group">
            <button class="btn-diff" onclick="startGame('EASY')">EASY</button>
            <button class="btn-diff" onclick="startGame('NORMAL')">NORMAL</button>
            <button class="btn-diff" onclick="startGame('HARD')">HARD</button>
            <button class="btn-diff btn-master" onclick="startGame('MASTER')">MASTER</button>
        </div>
    </div>

    <div id="screen-pause" class="screen hidden active-ui">
        <div class="modal">
            <h2 style="color:var(--c-perfect); font-weight:400; letter-spacing:0.2em; margin-bottom:3vh; font-size: 5vh;">PAUSED</h2>
            <div class="settings-group">
                <div class="setting-row">
                    <span style="width: 15vh; text-align: right;">SPEED</span>
                    <button class="btn-offset" onclick="adjustSpeed(-0.1)">-</button>
                    <span id="speed-display" style="width: 10vh; text-align: center;">1.0</span>
                    <button class="btn-offset" onclick="adjustSpeed(0.1)">+</button>
                </div>
                <div class="setting-row">
                    <span style="width: 15vh; text-align: right;">OFFSET</span>
                    <button class="btn-offset" onclick="adjustOffset(-5)">-</button>
                    <span id="pause-offset-display" style="width: 10vh; text-align: center;">0 ms</span>
                    <button class="btn-offset" onclick="adjustOffset(5)">+</button>
                </div>
                <div class="setting-row">
                    <span style="width: 15vh; text-align: right;">JUDGE X</span>
                    <button class="btn-offset" onclick="adjustJudgeRangeX(-0.01)">-</button>
                    <span id="judge-x-display" style="width: 10vh; text-align: center;">25%</span>
                    <button class="btn-offset" onclick="adjustJudgeRangeX(0.01)">+</button>
                </div>
                <div class="setting-row">
                    <span style="width: 15vh; text-align: right;">JUDGE Y</span>
                    <button class="btn-offset" onclick="adjustJudgeRangeY(-0.01)">-</button>
                    <span id="judge-y-display" style="width: 10vh; text-align: center;">15%</span>
                    <button class="btn-offset" onclick="adjustJudgeRangeY(0.01)">+</button>
                </div>
                <div class="setting-row">
                    <span style="width: 15vh; text-align: right;">SFX</span>
                    <button class="btn-offset" onclick="changeSFX(-1)">&lt;</button>
                    <span id="sfx-display" style="width: 15vh; text-align: center; font-size: 2.5vh;">DEFAULT</span>
                    <button class="btn-offset" onclick="changeSFX(1)">&gt;</button>
                </div>
                <div class="setting-row">
                    <span style="width: 15vh; text-align: right;">MUSIC</span>
                    <input type="range" id="vol-music" min="0" max="1" step="0.1" value="1" onchange="updateVolume()" style="width: 35vh;">
                    <span style="width: 4vh"></span>
                </div>
                <div class="setting-row">
                    <span style="width: 15vh; text-align: right;">SFX</span>
                    <input type="range" id="vol-sfx" min="0" max="1" step="0.1" value="1" onchange="updateVolume()" style="width: 35vh;">
                    <span style="width: 4vh"></span>
                </div>
            </div>
            <button class="btn-modal" onclick="resumeGame()">RESUME</button>
            <button class="btn-modal" onclick="quitGame()">EXIT</button>
        </div>
    </div>

    <div id="screen-result" class="screen hidden active-ui">
        <div class="modal">
            <h2 style="color:#666; font-size:2.5vh; letter-spacing:0.3em; margin-bottom:0;">SESSION ENDED</h2>
            <h1 id="res-rank" style="font-size:15vh; color:var(--c-perfect); margin:1vh 0; text-shadow:0 0 20px rgba(230,194,136,0.3);">S</h1>
            <div style="text-align:left; font-size:3vh; color:#ccc; line-height:1.6; margin-bottom:3vh;">
                <div style="display:flex; justify-content:space-between; border-bottom:1px solid #333;"><span>Score</span><span id="res-score">0</span></div>
                <div style="display:flex; justify-content:space-between;"><span>Max Combo</span><span id="res-combo">0</span></div>
                <div style="display:flex; justify-content:space-between; color:var(--c-perfect); margin-top:1vh;"><span>Perfect</span><span id="stat-p">0</span></div>
                <div style="display:flex; justify-content:space-between; color:var(--c-great)"><span>Great</span><span id="stat-gr">0</span></div>
                <div style="display:flex; justify-content:space-between; color:var(--c-good)"><span>Good</span><span id="stat-gd">0</span></div>
                <div style="display:flex; justify-content:space-between; color:var(--c-miss)"><span>Miss</span><span id="stat-m">0</span></div>
            </div>
            <button class="btn-modal" onclick="quitGame()">RETURN</button>
        </div>
    </div>

    <div id="countdown"></div>
</div>

<audio id="bgm"></audio>
<audio id="preview"></audio>

<script>
const SFX_SETS = [
    {
        name: "DEFAULT",
        TAP: "https://files.catbox.moe/5ehsef.mp3",
        SLIDE: "https://files.catbox.moe/gwxcg0.mp3",
        HOLD: "https://files.catbox.moe/h3e5ma.mp3",
        HOLD_END: "https://files.catbox.moe/gwxcg0.mp3",
        FLICK: "https://files.catbox.moe/gwxcg0.mp3"
    },
    {
        name: "DRUM",
        TAP: "https://files.catbox.moe/jc4vn1.mp3", 
        SLIDE: "https://files.catbox.moe/vqw5f5.mp3",
        HOLD: "https://files.catbox.moe/jc4vn1.mp3",
        HOLD_END: "https://files.catbox.moe/jc4vn1.mp3",
        FLICK: "https://files.catbox.moe/vqw5f5.mp3"
    },
    {
        name: "CLAP",
        TAP: "https://files.catbox.moe/bfaa01.mp3", 
        SLIDE: "https://files.catbox.moe/qcs95q.mp3",
        HOLD: "https://files.catbox.moe/f946jf.mp3",
        HOLD_END: "https://files.catbox.moe/qcs95q.mp3",
        FLICK: "https://files.catbox.moe/qcs95q.mp3"
    },
];
let currentSFXIndex = 0;
let SFX = SFX_SETS[0];

const SONGS = [
    { id: 0, title: "01.泥土裡的壞脾氣", color: "#66ff66", cover: "https://i.meee.com.tw/YCIig0r.jpg", src: "https://files.catbox.moe/n0otl1.mp3", preview: 10.4 },
    { id: 1, title: "02.無頭騎士序曲", color: "#ff4500", cover: "https://meee.com.tw/VJB7LBg.jpg", src: "https://files.catbox.moe/9aqtcj.mp3", preview: 14.4 },
    { id: 2, title: "03.鏽蝕的脈搏", color: "#8b4513", cover: "https://files.catbox.moe/xivzat.jpg", src: "https://files.catbox.moe/rqwk8s.mp3", preview: 10 },
    { id: 3, title: "04.霧都點名簿", color: "#232896", cover: "https://files.catbox.moe/axic1b.jpg", src: "https://files.catbox.moe/9mz87d.mp3", preview: 10 },
    { id: 4, title: "05.星盤下的謊言", color: "#ff0000", cover: "https://files.catbox.moe/4pis1o.jpg", src: "https://files.catbox.moe/tkok9u.mp3", preview: 10 },
    { id: 5, title: "06.泛黃的處方籤", color: "#eee8aa", cover: "https://files.catbox.moe/5wamgm.jpg", src: "https://files.catbox.moe/fyxcfi.mp3", preview: 10 },
    { id: 6, title: "07.這麻煩有點大", color: "#9394E6", cover: "https://files.catbox.moe/oi2lh5.jpg", src: "https://files.catbox.moe/g8dbzw.mp3", preview: 10 },
    { id: 7, title: "08.絕對無菌的處刑曲", color: "#85846A", cover: "https://files.catbox.moe/ishaxg.jpg", src: "https://files.catbox.moe/ffb3gz.mp3", preview: 10 },
    { id: 8, title: "09.真理跪拜於我", color: "#00008b", cover: "https://files.catbox.moe/q06wsw.jpg", src: "https://files.catbox.moe/8mo7mf.mp3", preview: 10 },
    { id: 9, title: "10.玻璃的恩典", color: "#87ceeb", cover: "https://files.catbox.moe/unqwk1.jpg", src: "https://files.catbox.moe/9lxu2s.mp3", preview: 10 },
    { id: 10, title: "11.易碎的明天", color: "#ffd700", cover: "https://files.catbox.moe/5mfu5q.jpg", src: "https://files.catbox.moe/4j2pty.mp3", preview: 10 },
    { id: 11, title: "12.越界的代價", color: "#4C3E80", cover: "https://files.catbox.moe/zmpmwk.jpg", src: "https://files.catbox.moe/kg60ar.mp3", preview: 10 },
    { id: 12, title: "13.融入的藝術", color: "#ff69b4", cover: "https://files.catbox.moe/usm7nv.jpg", src: "https://files.catbox.moe/v2dt14.mp3", preview: 10 },
    { id: 13, title: "14.名為永恆的毒蘋果", color: "#800080", cover: "https://files.catbox.moe/2xbvom.jpg", src: "https://files.catbox.moe/5wtu1z.mp3", preview: 10 },
    { id: 14, title: "15.零層會議", color: "#333333", cover: "https://files.catbox.moe/bgpkld.jpg", src: "https://files.catbox.moe/mklbah.mp3", preview: 10 },
    { id: 15, title: "16.最初的清晨", color: "#F5CC5B", cover: "https://files.catbox.moe/y6efl4.jpg", src: "https://files.catbox.moe/xcbk67.mp3", preview: 10 }
,{ id: 16, title: "Coming soon", color: "#ffffff", cover: "https://files.catbox.moe/ypzq8c.jpg", src: "", preview: 10 }
];

const STORAGE_KEY = 'nocturne_save_v6'; 
let userOffset = parseInt(localStorage.getItem('nocturne_offset') || 0);
let userSpeed = parseFloat(localStorage.getItem('nocturne_speed') || 1.0);
let musicVol = parseFloat(localStorage.getItem('nocturne_mvol') || 1.0);
let sfxVol = parseFloat(localStorage.getItem('nocturne_svol') || 1.0);

function adjustOffset(delta) {
    userOffset += delta;
    if(userOffset > 200) userOffset = 200;
    if(userOffset < -200) userOffset = -200;
    localStorage.setItem('nocturne_offset', userOffset);
    const display = document.getElementById('pause-offset-display');
    if(display) display.innerText = (userOffset > 0 ? "+" : "") + userOffset + " ms";
}

function adjustSpeed(delta) {
    userSpeed += delta;
    userSpeed = Math.round(userSpeed * 10) / 10;
    if(userSpeed < 0.5) userSpeed = 0.5;
    if(userSpeed > 8.0) userSpeed = 8.0;
    localStorage.setItem('nocturne_speed', userSpeed);
    document.getElementById('speed-display').innerText = userSpeed.toFixed(1);
    
    if (gameState === 'PAUSE') {
        let base = 2.0;
        if (currentDiff === 'EASY') base = 2.2;
        else if (currentDiff === 'NORMAL') base = 2.0;
        else if (currentDiff === 'HARD') base = 1.6;
        else if (currentDiff === 'MASTER') base = 1.3;
        currentFallTime = base / userSpeed;
    }
}

function updateVolume() {
    musicVol = parseFloat(document.getElementById('vol-music').value);
    sfxVol = parseFloat(document.getElementById('vol-sfx').value);
    localStorage.setItem('nocturne_mvol', musicVol);
    localStorage.setItem('nocturne_svol', sfxVol);
    const bgm = document.getElementById('bgm');
    const preview = document.getElementById('preview');
    if(bgm) bgm.volume = musicVol;
    if(preview) preview.volume = musicVol;
}

function saveHighScore(songId, diff, score, rank) {
    let save = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
    if (!save[songId]) save[songId] = {};
    if (!save[songId][diff] || score > save[songId][diff].score) {
        save[songId][diff] = { score: score, rank: rank };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(save));
    }
}
function getHighScore(songId, diff) {
    let save = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
    return (save[songId] && save[songId][diff]) ? save[songId][diff] : null;
}

// Seeded RNG helper
function createSeededRandom(seed) {
    return function() {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
    };
}

// --- GENERATOR (V34+ SEEDED) ---
function generateChart(jsonData, diff) {
    if (!jsonData || !jsonData.tracks) {
        return [
            {t: 2.0, d:0, xPct: 0.2, type:0, songColor: "#fff", hit:false, holding:false, holdingTouchId:null, missed:false},
            {t: 2.5, d:0, xPct: 0.8, type:0, songColor: "#fff", hit:false, holding:false, holdingTouchId:null, missed:false},
            {t: 3.0, d:0, xPct: 0.5, type:0, songColor: "#fff", hit:false, holding:false, holdingTouchId:null, missed:false},
            {t: 4.0, d:1.0, xPct: 0.3, type:2, songColor: "#fff", hit:false, holding:false, holdingTouchId:null, missed:false}
        ];
    }
    
    // Initialize Seeded RNG for Consistency
    let rng = createSeededRandom(currentSongIdx + diff.charCodeAt(0) * 100);

    let allNotes = [];
    jsonData.tracks.forEach(t => { if(t.notes) allNotes = allNotes.concat(t.notes); });
    allNotes.sort((a,b) => a.time - b.time);

    let minGap = 0.5; 
    if (diff === 'EASY') minGap = 1.0;
    else if (diff === 'NORMAL') minGap = 0.5; 
    else if (diff === 'HARD') minGap = 0.24; 
    else if (diff === 'MASTER') minGap = 0.15; 

    let gameNotes = [];
    let lastTime = -99;
    let lastX = 0.5; 
    
    let timeGroups = [];
    let currentGroup = [];
    allNotes.forEach(n => {
        if (currentGroup.length === 0) currentGroup.push(n);
        else {
            if (Math.abs(n.time - currentGroup[0].time) < 0.02) currentGroup.push(n);
            else { timeGroups.push(currentGroup); currentGroup = [n]; }
        }
    });
    if(currentGroup.length > 0) timeGroups.push(currentGroup);

    let activeHoldsSim = []; 

    timeGroups.forEach((group, idx) => {
        let t = group[0].time;
        if (t - lastTime < minGap) return; 

        activeHoldsSim = activeHoldsSim.filter(h => h.endTime > t + 0.1);
        let availableSlots = 2 - activeHoldsSim.length;
        if (availableSlots <= 0) return; 

        let notesToProcess = group.slice(0, availableSlots);
        let placedX = [];
        
        notesToProcess.forEach((note, noteIdx) => {
            let xPct;
            let avoidX = [];
            activeHoldsSim.forEach(h => avoidX.push(h.x));
            placedX.forEach(px => avoidX.push(px));

            // Seeded RNG for X position
            if (avoidX.length > 0) {
                let refX = avoidX[0]; 
                if (refX < 0.5) xPct = 0.6 + (rng() * 0.3); 
                else xPct = 0.1 + (rng() * 0.3); 
                if (placedX.length > 0) { if (placedX[0] < 0.5) xPct = 0.75; else xPct = 0.25; }
            } else {
                let timeDelta = t - lastTime;
                if (timeDelta < 0.8) { 
                    if (lastX < 0.5) xPct = 0.6 + (rng() * 0.3); 
                    else xPct = 0.1 + (rng() * 0.3); 
                } else {
                    xPct = 0.15 + (rng() * 0.7); 
                }
            }

            let type = 0; 
            let duration = 0;
            
            if (note.duration > 0.3) { 
                type = 2; duration = note.duration; 
                if (duration > 1.2) type = 6; 
            } 
            else if (notesToProcess.length > 1 && (diff === 'MASTER' || diff === 'HARD')) { type = 1; } 
            else if ((diff === 'MASTER' || diff === 'HARD') && idx < timeGroups.length - 1) {
                let next = timeGroups[idx+1][0];
                let threshold = 0.18;
                let slideChance = (diff === 'HARD') ? 0.15 : 0.4; 
                
                if (next.time - t < threshold && rng() < slideChance) { 
                    type = 3; 
                }
            }
            
            // FLICK GENERATION
            if (type === 0) {
                let flickChance = 0.0;
                if (diff === 'EASY') flickChance = 0.05;
                else if (diff === 'NORMAL') flickChance = 0.08;
                else if (diff === 'HARD' || diff === 'MASTER') flickChance = 0.06;

                if (rng() < flickChance) {
                    let r = rng();
                    if (diff === 'EASY') {
                        // Easy: L/R only
                        type = (r > 0.5) ? 4 : 5;
                    } 
                    else if (diff === 'NORMAL') {
                        // Normal: L/R + U/D
                        if (r < 0.25) type = 4;
                        else if (r < 0.5) type = 5;
                        else if (r < 0.75) type = 7;
                        else type = 8;
                    }
                    else {
                        // Hard/Master: All
                        if (r < 0.25) type = 4;
                        else if (r < 0.5) type = 5;
                        else if (r < 0.75) type = 7;
                        else type = 8;
                    }
                }
            }

            // Slide Chain
            if (type === 3 && idx > 0) {
                let prevT = lastTime;
                let prevX = lastX;
                let density = 0.06;
                let steps = Math.floor((t - prevT) / density); 
                if (steps > 0 && steps < 10) {
                    for(let k=1; k<=steps; k++) {
                        let lerpT = prevT + (t - prevT) * (k / (steps+1));
                        let lerpX = prevX + (xPct - prevX) * (k / (steps+1));
                        gameNotes.push({ t: lerpT, d: 0, xPct: lerpX, type: 3, hit: false, holding: false, holdingTouchId: null, missed: false, songColor: null });
                    }
                }
            }

            if (type === 2 || type === 6) activeHoldsSim.push({ endTime: t + duration, x: xPct });
            placedX.push(xPct);
            lastX = xPct;
            gameNotes.push({ t: t, d: duration, xPct: xPct, type: type, hit: false, holding: false, holdingTouchId: null, missed: false, songColor: null });
        });
        
        if (notesToProcess.length > 0) lastTime = t;
    });

    gameNotes.sort((a,b) => a.t - b.t);
    return gameNotes;
}

const PERSPECTIVE_TOP_SCALE = 0.5; // Top is 50% of bottom width

let currentFallTime = 2.0; 
const JUDGE_LINE_PCT = 0.65; 
let userJudgeX = parseFloat(localStorage.getItem('nocturne_judgeX') || 0.25);
let userJudgeY = parseFloat(localStorage.getItem('nocturne_judgeY') || 0.15);
const AUDIO_DELAY = 3.0; 
const P_WIN = 0.08; const GR_WIN = 0.15; const GD_WIN = 0.25; 

let canvas, ctx, inputZone;
let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let sfxBuffers = {};
let currentSongIdx = 0;
let currentDiff = 'NORMAL';
let gameState = "HOME"; 
let width, height;

let activeNotes = [];
let particles = [];
let touchFeedback = []; 
let hitEffects = [];
let score = 0, combo = 0, maxCombo = 0;
let scorePerNote = 0;
let stats = { p:0, gr:0, gd:0, m:0 };
let pTimer, pFade;
let gameStartTime = 0;
let isAudioPlaying = false;
let countdownTimer = null;
let pausedFrom = "HOME";
let pausedTime = 0;

window.onload = () => {
    canvas = document.getElementById('game');
    inputZone = document.getElementById('input-zone');
    ctx = canvas.getContext('2d');
    handleResize();
    window.addEventListener('resize', handleResize);
    loadSFXSet(SFX);
    initCarousel(); 
    updateHomeUI();
    document.getElementById('pause-offset-display').innerText = (userOffset > 0 ? "+" : "") + userOffset + " ms";
    document.getElementById('speed-display').innerText = userSpeed.toFixed(1);
    document.getElementById('vol-music').value = musicVol;
    document.getElementById('vol-sfx').value = sfxVol;
    updateJudgeRangeUI();
    loop();
    const bind = (evt) => inputZone.addEventListener(evt, handleInput, {passive:false});
    bind('mousedown'); bind('touchstart'); bind('touchmove'); bind('touchend'); bind('mouseup');
};

function handleResize() {
    const container = document.getElementById('play-container');
    const rect = container.getBoundingClientRect();
    width = rect.width; height = rect.height;
    canvas.width = width; canvas.height = height;
}

function adjustJudgeRangeX(delta) {
    userJudgeX += delta;
    if(userJudgeX < 0.05) userJudgeX = 0.05;
    if(userJudgeX > 0.5) userJudgeX = 0.5;
    userJudgeX = Math.round(userJudgeX*100)/100;
    localStorage.setItem('nocturne_judgeX', userJudgeX);
    updateJudgeRangeUI();
}

function adjustJudgeRangeY(delta) {
    userJudgeY += delta;
    if(userJudgeY < 0.05) userJudgeY = 0.05;
    if(userJudgeY > 0.5) userJudgeY = 0.5;
    userJudgeY = Math.round(userJudgeY*100)/100;
    localStorage.setItem('nocturne_judgeY', userJudgeY);
    updateJudgeRangeUI();
}

function updateJudgeRangeUI() {
    const dx = document.getElementById('judge-x-display');
    if(dx) dx.innerText = Math.round(userJudgeX*100) + "%";
    const dy = document.getElementById('judge-y-display');
    if(dy) dy.innerText = Math.round(userJudgeY*100) + "%";
}

async function loadSFX(url, key) {
    try { const res = await fetch(url); const buf = await res.arrayBuffer(); sfxBuffers[key] = await audioCtx.decodeAudioData(buf); } catch(e){}
}

async function loadSFXSet(set) {
    await Promise.all(Object.keys(set).filter(k => k !== 'name').map(k => loadSFX(set[k], k)));
}

function playSFX(key) {
    if (SFX.synth) {
        triggerSynth(SFX.synth, key);
        return;
    }
    if(!sfxBuffers[key]) return;
    const s = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    s.buffer = sfxBuffers[key];
    g.gain.value = sfxVol;
    s.connect(g); g.connect(audioCtx.destination);
    s.start(0);
}

function triggerSynth(style, key) {
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(sfxVol * 0.5, now);
    if (style === 'ELECTRO') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(key === 'FLICK' ? 880 : 440, now);
        osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(key === 'FLICK' ? 660 : 330, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
    }
}

function initCarousel() { 
    const diffs = ['EASY', 'NORMAL', 'HARD', 'MASTER'];
    document.getElementById('carousel').innerHTML = SONGS.map((s,i) => {
        let rankHtml = '<div class="rank-row">';
        diffs.forEach(d => {
            const data = getHighScore(s.id, d);
            rankHtml += data ? `<span class="rank-item rank-${data.rank}">${data.rank}</span>` : `<span class="rank-item rank-none">●</span>`;
        });
        rankHtml += '</div>';
        return `<div class="song-card" id="card-${i}" onclick="changeSong(${i})">${rankHtml}<div class="card-img-wrap"><img src="${s.cover}"></div><div class="song-title-overlay">${s.title}</div></div>`;
    }).join(''); 
}

function updateHomeUI() {
    SONGS.forEach((_, i) => {
        const el = document.getElementById(`card-${i}`);
        el.classList.remove('c-center', 'c-left', 'c-right', 'c-hidden-left', 'c-hidden-right');
        const dist = i - currentSongIdx;
        if (dist === 0) el.style.zIndex = 100; else el.style.zIndex = 50 - Math.abs(dist);
        if(dist === 0) el.classList.add('c-center');
        else if (dist === -1) el.classList.add('c-left');
        else if (dist === 1) el.classList.add('c-right');
        else if (dist < -1) el.classList.add('c-hidden-left');
        else if (dist > 1) el.classList.add('c-hidden-right');
    });
    document.getElementById('bg-layer').style.backgroundImage = `url(${SONGS[currentSongIdx].cover})`;
    document.querySelector('.pause-icon').innerText = "⚙";
    startPreview();
}

function changeSong(i) { 
    if(i>=0&&i<SONGS.length){
        playSFX('TAP');
        currentSongIdx=i; 
        updateHomeUI();
    } 
}

function startPreview() {
    stopPreview();
    const aud = document.getElementById('preview');
    aud.src = SONGS[currentSongIdx].src; aud.currentTime = SONGS[currentSongIdx].preview; aud.volume = musicVol;
    const cycle = () => {
        aud.currentTime = SONGS[currentSongIdx].preview; aud.play().catch(()=>{});
        let v=0;
        pFade = setInterval(()=>{ v+=0.05; if(v>=1){v=1;clearInterval(pFade);} aud.volume=v; }, 50);
        pTimer = setTimeout(()=>{
            let out = setInterval(()=>{ aud.volume = Math.max(0, aud.volume - 0.05); if(aud.volume<=0){ aud.pause(); clearInterval(out); cycle(); } }, 50);
        }, 12000);
    };
    cycle();
}
function stopPreview() {
    const aud = document.getElementById('preview');
    clearInterval(pFade); clearTimeout(pTimer); aud.pause(); aud.currentTime=0; aud.volume=0;
}

function startGame(diff) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    stopPreview();
    currentDiff = diff;
    
    if (diff === 'MASTER') {
        document.documentElement.style.setProperty('--master-color', SONGS[currentSongIdx].color);
        document.getElementById('master-layer').style.opacity = 0.5;
    } else {
        document.getElementById('master-layer').style.opacity = 0;
    }

    if (diff === 'EASY') currentFallTime = 2.2;
    else if (diff === 'NORMAL') currentFallTime = 2.0;
    else if (diff === 'HARD') currentFallTime = 1.6; 
    else if (diff === 'MASTER') currentFallTime = 1.3; 
    currentFallTime /= userSpeed;

    const song = SONGS[currentSongIdx];
    const notes = generateChart(JSON_DB[song.id], diff);
    activeNotes = notes.map(n => ({...n, songColor: song.color}));
    score=0; combo=0; maxCombo=0; stats={p:0,gr:0,gd:0,m:0}; particles=[]; touchFeedback=[]; hitEffects=[];
    
    scorePerNote = activeNotes.length > 0 ? (1000000 / activeNotes.length) : 0;

    document.getElementById('score').innerText = "000000";
    document.getElementById('combo').innerText = "";
    
    document.getElementById('screen-home').classList.add('hidden');
    document.getElementById('screen-home').classList.remove('active-ui');
    document.querySelector('.pause-icon').innerText = "||";
    const cd = document.getElementById('countdown');
    cd.style.opacity = 1; gameState = "COUNTDOWN";
    let c = 3; cd.innerText = c;
    countdownTimer = setInterval(() => {
        c--;
        if(c>0) cd.innerText=c;
        else {
            clearInterval(countdownTimer); cd.innerText=""; cd.style.opacity=0;
            document.getElementById('screen-hud').classList.remove('hidden');
            gameState="PLAY";
            const bgm = document.getElementById('bgm');
            bgm.src = song.src; bgm.currentTime = 0; bgm.volume = 1;
            isAudioPlaying = false;
            gameStartTime = performance.now(); 
        }
    }, 1000);
}

function getSnakeOffset(t, startTime) {
    return Math.sin((t - startTime) * 5) * 0.15; 
}

async function changeSFX(dir) {
    currentSFXIndex = (currentSFXIndex + dir + SFX_SETS.length) % SFX_SETS.length;
    SFX = SFX_SETS[currentSFXIndex];
    document.getElementById('sfx-display').innerText = SFX.name;
    await loadSFXSet(SFX);
    playSFX('TAP');
}

function getPerspective(pct) {
    const s = PERSPECTIVE_TOP_SCALE + (1 - PERSPECTIVE_TOP_SCALE) * pct;
    const lw = width * s;
    const xo = (width - lw) / 2;
    return { s, lw, xo };
}

function loop() {
    requestAnimationFrame(loop);
    if(gameState !== "PLAY" && gameState !== "COUNTDOWN" && gameState !== "RESULT" && gameState !== "RESUME_WAIT") { 
        if(gameState === "HOME" || gameState === "PAUSE") ctx.clearRect(0,0,width,height);
        return; 
    }
    ctx.clearRect(0,0,width,height);
    
    touchFeedback.forEach((tf, i) => {
        tf.life -= 0.08;
        if(tf.life > 0) {
            ctx.beginPath(); ctx.arc(tf.x, tf.y, 60 * (1-tf.life), 0, Math.PI*2);
            ctx.strokeStyle = `rgba(255,255,255,${tf.life})`; ctx.stroke();
        } else { touchFeedback.splice(i,1); }
    });

    const JUDGE_Y = height * JUDGE_LINE_PCT;
    const songColor = SONGS[currentSongIdx].color;

    const topWidth = width * PERSPECTIVE_TOP_SCALE;
    const topXOffset = (width - topWidth) / 2;
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const xPct = 0.1 + i * 0.08;
        const topX = topXOffset + xPct * topWidth;
        const bottomX = xPct * width;
        ctx.beginPath();
        ctx.moveTo(topX, 0);
        ctx.lineTo(bottomX, JUDGE_Y);
        ctx.stroke();
    }
    
    ctx.shadowBlur = 15; ctx.shadowColor = songColor;
    ctx.strokeStyle = "rgba(255,255,255,0.8)"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, JUDGE_Y); ctx.lineTo(width, JUDGE_Y); ctx.stroke();
    ctx.shadowBlur = 0;

    // Draw Hit Effects
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    hitEffects.forEach((he, i) => {
        he.life -= 0.05;
        if(he.life > 0) {
            ctx.globalAlpha = he.life * 0.5;
            ctx.shadowBlur = 60;
            ctx.shadowColor = he.color;
            ctx.fillStyle = he.color;
            ctx.beginPath(); ctx.ellipse(he.x, he.y, 80 * he.life, 20 * he.life, 0, 0, Math.PI * 2); ctx.fill();
            
            ctx.globalAlpha = he.life;
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#fff";
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.ellipse(he.x, he.y, 40 * he.life, 8 * he.life, 0, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        } else {
            hitEffects.splice(i, 1);
        }
    });
    ctx.restore();

    if(gameState==="COUNTDOWN") return;
    
    const bgm = document.getElementById('bgm');
    let rawTime;
    
    if (gameState === "RESUME_WAIT") {
        rawTime = pausedTime;
    } else if (isAudioPlaying) {
        rawTime = bgm.currentTime;
        if(bgm.ended) { showResult(); return; }
    } else {
        let elapsed = (performance.now() - gameStartTime) / 1000;
        rawTime = elapsed - AUDIO_DELAY;
        if (rawTime >= 0) {
            bgm.play().then(() => { isAudioPlaying = true; }).catch(e => console.log(e));
            if(!isAudioPlaying) rawTime = 0; 
        }
    }

    const currentTime = rawTime - (userOffset / 1000);

    activeNotes.forEach(n => {
        if(n.missed) return;
        const dt = n.t - currentTime;
        const fallPct = 1 - (dt / currentFallTime);
        if(fallPct < -0.2) return; 

        const { s: scale, lw: currentLaneWidth, xo: xOffset } = getPerspective(fallPct);
        const ny = fallPct * JUDGE_Y;
        const nx = xOffset + n.xPct * currentLaneWidth;
        const nw = (width * 0.155) * scale;
        const nh = (height * 0.038) * scale; //音符高度

        if(dt < -GD_WIN && !n.hit && !n.holding) {
            n.missed = true; combo=0; stats.m++; triggerJudge("MISS", "var(--c-miss)"); updateHUD();
        }

        // --- DRAW HOLD BODY ---
        if((n.type===2 || n.type===6) && n.d>0) {
            const tailPct = 1 - ((n.t + n.d - currentTime) / currentFallTime);
            let startPct = n.holding ? 1.0 : fallPct; 
            let endPct = tailPct;
            
            // Clip to screen
            let visibleStartPct = Math.min(startPct, 1.5);
            let visibleEndPct = Math.max(0, endPct);

            if(visibleStartPct > visibleEndPct) { 
                if (n.type === 2) {
                    // Perspective Hold Body
                    const bottom = getPerspective(visibleStartPct);
                    const top = getPerspective(visibleEndPct);
                    
                    const bx = bottom.xo + n.xPct * bottom.lw;
                    const by = visibleStartPct * JUDGE_Y;
                    const bw = (width * 0.155) * bottom.s;
                    
                    const tx = top.xo + n.xPct * top.lw;
                    const ty = visibleEndPct * JUDGE_Y;
                    const tw = (width * 0.155) * top.s;
                    
                    ctx.fillStyle = "rgba(255,255,255,0.3)";
                    ctx.beginPath(); ctx.moveTo(bx - bw/2, by); ctx.lineTo(bx + bw/2, by);
                    ctx.lineTo(tx + tw/2, ty); ctx.lineTo(tx - tw/2, ty); ctx.fill();
                    
                    ctx.fillStyle = songColor;
                    ctx.beginPath(); ctx.moveTo(bx - 2*bottom.s, by); ctx.lineTo(bx + 2*bottom.s, by);
                    ctx.lineTo(tx + 2*top.s, ty); ctx.lineTo(tx - 2*top.s, ty); ctx.fill();

                } else if (n.type === 6) {
                    // Snake Hold
                    const stepCount = 30; 
                    const pctStep = (visibleStartPct - visibleEndPct) / stepCount;
                    
                    ctx.fillStyle = "rgba(255,255,255,0.3)";
                    for (let i = 0; i < stepCount; i++) {
                        let p1 = visibleStartPct - i * pctStep;
                        let p2 = visibleStartPct - (i+1) * pctStep;
                        let t1 = currentTime + (1 - p1) * currentFallTime;
                        let t2 = currentTime + (1 - p2) * currentFallTime;
                        let off1 = getSnakeOffset(t1, n.t);
                        let off2 = getSnakeOffset(t2, n.t);
                        let persp1 = getPerspective(p1);
                        let persp2 = getPerspective(p2);
                        let x1 = persp1.xo + (n.xPct + off1) * persp1.lw;
                        let w1 = (width * 0.155) * persp1.s;
                        let y1 = p1 * JUDGE_Y;
                        let x2 = persp2.xo + (n.xPct + off2) * persp2.lw;
                        let w2 = (width * 0.155) * persp2.s;
                        let y2 = p2 * JUDGE_Y;
                        
                        ctx.beginPath(); ctx.moveTo(x1 - w1/2, y1); ctx.lineTo(x1 + w1/2, y1);
                        ctx.lineTo(x2 + w2/2, y2); ctx.lineTo(x2 - w2/2, y2); ctx.fill();
                    }
                }
            }
            if(n.holding && currentTime > n.t + n.d) {
                n.hit=true; n.missed=true; addScore(1.0); combo++; triggerJudge("PERFECT", "var(--c-perfect)"); updateHUD();
                playSFX('HOLD_END');
                hitEffects.push({x: nx, y: JUDGE_Y, life: 1, color: songColor});
                n.holdingTouchId = null; 
            }
        }

        // --- DRAW NOTE HEAD ---
        if(!n.hit && !n.holding && ny < height + 50) {
            if(ny > -50) { 
                ctx.shadowBlur = 20 * scale; ctx.shadowColor = songColor;
                
                let drawX = nx;
                if (n.type === 6) {
                    let offX = getSnakeOffset(n.t, n.t); 
                    drawX = xOffset + (n.xPct + offX) * currentLaneWidth;
                }

                if (n.type === 3) {
                    // Slide - Perspective Diamond (Flat)
                    const sNw = nw * 0.8;
                    const sNh = nh * 0.8;
                    const yTop = ny - sNh/2;
                    const yBot = ny + sNh/2;
                    
                    ctx.beginPath();
                    ctx.moveTo(drawX, yTop); // Top Center
                    ctx.lineTo(drawX + sNw/2, ny); // Right
                    ctx.lineTo(drawX, yBot); // Bottom Center
                    ctx.lineTo(drawX - sNw/2, ny); // Left
                    ctx.closePath();
                    
                    // 3. 滑鍵 (Slide/Drag) - 全白，白光暈
                    ctx.shadowBlur = 20 * scale; 
                    ctx.shadowColor = "#ffffff"; // White Halo
                    ctx.fillStyle = "#ffffff"; 
                    ctx.fill();
                } 
                else if (n.type >= 4 && n.type <= 8 && n.type !== 6) {
                    // Flick - Perspective Arrow
                    const yTop = ny - nh/2;
                    const yBot = ny + nh/2;
                    const pTop = getPerspective(yTop / JUDGE_Y);
                    const pBot = getPerspective(yBot / JUDGE_Y);
                    
                    const wTop = (width * 0.155) * pTop.s * 0.9; 
                    const wBot = (width * 0.155) * pBot.s * 0.9;
                    
                    const xTop = pTop.xo + n.xPct * pTop.lw;
                    const xBot = pBot.xo + n.xPct * pBot.lw;

                    const drawArrow = (scaleFactor) => {
                        const cx = (xTop + xBot) / 2;
                        const cy = (yTop + yBot) / 2;
                        const lx = (x) => cx + (x - cx) * scaleFactor;
                        const ly = (y) => cy + (y - cy) * scaleFactor;

                        ctx.beginPath();
                        if (n.type === 7) { // Up
                            ctx.moveTo(lx(xTop), ly(yTop)); ctx.lineTo(lx(xBot + wBot/2), ly(yBot)); ctx.lineTo(lx(xBot - wBot/2), ly(yBot));
                        } else if (n.type === 8) { // Down
                            ctx.moveTo(lx(xBot), ly(yBot)); ctx.lineTo(lx(xTop + wTop/2), ly(yTop)); ctx.lineTo(lx(xTop - wTop/2), ly(yTop));
                        } else if (n.type === 4) { // Left
                            const midY = (yTop + yBot) / 2; const midX = ( (xTop - wTop/2) + (xBot - wBot/2) ) / 2;
                            ctx.moveTo(lx(midX), ly(midY)); ctx.lineTo(lx(xTop + wTop/2), ly(yTop)); ctx.lineTo(lx(xBot + wBot/2), ly(yBot));
                        } else if (n.type === 5) { // Right
                            const midY = (yTop + yBot) / 2; const midX = ( (xTop + wTop/2) + (xBot + wBot/2) ) / 2;
                            ctx.moveTo(lx(midX), ly(midY)); ctx.lineTo(lx(xTop - wTop/2), ly(yTop)); ctx.lineTo(lx(xBot - wBot/2), ly(yBot));
                        }
                        ctx.closePath();
                    };

                    // 2. 上/下/左/右滑鍵 (Flick) - 歌曲色填充，加粗白框，歌曲色光暈
                    drawArrow(1.1);
                    ctx.shadowBlur = 20 * scale; 
                    ctx.shadowColor = "#ffffff"; // Song Color Halo
                    ctx.fillStyle = songColor; // Song Color Fill
                    ctx.fill();
                    ctx.lineWidth = 4 * scale; 
                    ctx.strokeStyle = "#ffffff"; // White Border
                    ctx.stroke();
                } else {
                    // Tap / Hold Head / Big Tap - Perspective Trapezoid (Bar)
                    const yTop = ny - nh/2;
                    const yBot = ny + nh/2;
                    const pTop = getPerspective(yTop / JUDGE_Y);
                    const pBot = getPerspective(yBot / JUDGE_Y);
                    const wTop = (width * 0.155) * pTop.s;
                    const wBot = (width * 0.155) * pBot.s;
                    const xTop = pTop.xo + n.xPct * pTop.lw;
                    const xBot = pBot.xo + n.xPct * pBot.lw;

                    if (n.type === 1) { 
                    // Big Tap - Stroke
                    ctx.save();
                    ctx.shadowBlur = 25 * scale; ctx.shadowColor = "rgba(255,255,255,0.9)"; // White Halo
                    ctx.fillStyle = "#000"; ctx.strokeStyle = songColor; ctx.lineWidth = 5;
                    
                    ctx.beginPath();
                    ctx.moveTo(xTop - wTop/2, yTop); ctx.lineTo(xTop + wTop/2, yTop);
                    ctx.lineTo(xBot + wBot/2, yBot); ctx.lineTo(xBot - wBot/2, yBot);
                    ctx.closePath();
                    ctx.fill(); ctx.stroke();

                    // Inner highlight
                    ctx.fillStyle = "rgba(255,255,255,0.8)";
                    ctx.beginPath();
                    ctx.moveTo(xTop - wTop/4, yTop + nh*0.25); ctx.lineTo(xTop + wTop/4, yTop + nh*0.25);
                    ctx.lineTo(xBot + wBot/4, yBot - nh*0.25); ctx.lineTo(xBot - wBot/4, yBot - nh*0.25);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // Normal Tap / Hold Head
                    ctx.fillStyle = "#fff"; 
                    ctx.beginPath();
                    ctx.moveTo(xTop - wTop/2, yTop); ctx.lineTo(xTop + wTop/2, yTop);
                    ctx.lineTo(xBot + wBot/2, yBot); ctx.lineTo(xBot - wBot/2, yBot);
                    ctx.fill();

                    // Colored strip
                    ctx.fillStyle = songColor;
                    ctx.beginPath();
                    ctx.moveTo(xTop - wTop/2 + 3*scale, yTop + nh*0.3); 
                    ctx.lineTo(xTop + wTop/2 - 3*scale, yTop + nh*0.3);
                    ctx.lineTo(xBot + wBot/2 - 3*scale, yBot - nh*0.3); 
                    ctx.lineTo(xBot - wBot/2 + 3*scale, yBot - nh*0.3);
                    ctx.fill();
                }
                }
                ctx.shadowBlur = 0;
            }
        }

        if(n.holding) {
             // Fixed point logic: Use the lane center at judge line (perspective 1.0)
             const pJudge = getPerspective(1.0);
             let currentX = n.xPct;
             if (n.type === 6) {
                 currentX += getSnakeOffset(currentTime, n.t);
             }
             let holdX = pJudge.xo + currentX * pJudge.lw;
             spawnParticles(holdX, JUDGE_Y, songColor, 2);
             ctx.shadowBlur=20; ctx.shadowColor=songColor;
             ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(holdX, JUDGE_Y, 20, 0, Math.PI*2); ctx.fill();
             ctx.shadowBlur=0;
        }
    });
    updateParticles();
}

let touchStartMap = new Map(); 
let touchStartPos = new Map(); 

function addScore(multiplier) {
    score += Math.floor(scorePerNote * multiplier);
    if (score > 1000000) score = 1000000;
}

function handleInput(e) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    if(gameState !== "PLAY") return;
    if(e.cancelable) e.preventDefault();
    const touches = e.changedTouches ? Array.from(e.changedTouches) : [e];
    const type = e.type;
    const bgm = document.getElementById('bgm');
    const rawTime = isAudioPlaying ? bgm.currentTime : ((performance.now()-gameStartTime)/1000 - AUDIO_DELAY);
    const time = rawTime - (userOffset / 1000); 
    
    const rect = inputZone.getBoundingClientRect();
    const NORMAL_X_WIN = width * userJudgeX; 
    const NORMAL_Y_WIN = width * userJudgeY; 
    const SLIDE_X_WIN = width * 0.05; 

    touches.forEach(t => {
        const tx = t.clientX - rect.left;
        const ty = t.clientY - rect.top;
        const id = t.identifier !== undefined ? t.identifier : 'mouse';

        if (type === 'touchstart' || type === 'mousedown') {
            touchFeedback.push({x:tx, y:ty, life:1});
            touchStartMap.set(id, tx); 
            touchStartPos.set(id, {x:tx, y:ty});
        }
        
        let deltaX = 0;
        let deltaY = 0;
        if (type === 'touchmove' || type === 'touchend' || type === 'mouseup') {
            if (touchStartPos.has(id)) {
                let start = touchStartPos.get(id);
                deltaX = tx - start.x;
                deltaY = ty - start.y;
            }
        }
        if (type === 'touchend' || type === 'mouseup') {
            touchStartMap.delete(id);
            touchStartPos.delete(id);
        }

        for (let i = 0; i < activeNotes.length; i++) {
            let n = activeNotes[i];
            if(n.hit || n.missed) continue; 
            
            let targetX = n.xPct * width;
            if (n.type === 6 && (n.holding || Math.abs(n.t - time) < GD_WIN)) {
                let checkTime = n.holding ? time : n.t;
                let offX = getSnakeOffset(checkTime, n.t);
                targetX = (n.xPct + offX) * width;
            }

            const dt = Math.abs(n.t - time);
            
            // HOLD
            if (n.type === 2 || n.type === 6) {
                if (type === 'touchstart' || type === 'mousedown' || (n.type===6 && type==='touchmove')) {
                    if (n.holding && n.holdingTouchId !== null && n.holdingTouchId !== id) continue; 
                    
                    let isStartHit = (type === 'touchstart' || type === 'mousedown') && dt <= GD_WIN && Math.abs(tx - targetX) < NORMAL_X_WIN;
                    
                    if (n.type === 6 && n.holding && n.holdingTouchId === id) {
                        if (Math.abs(tx - targetX) > NORMAL_X_WIN * 1.5) {
                            n.holding = false; n.missed = true; combo=0; stats.m++; triggerJudge("MISS", "var(--c-miss)"); updateHUD();
                        }
                        break; 
                    }

                    if(isStartHit && !n.holding) {
                        playSFX('HOLD'); n.holding = true;
                        hitEffects.push({x: targetX, y: height*JUDGE_LINE_PCT, life: 1, color: n.songColor});
                        n.holdingTouchId = id;
                        break; 
                    }
                }
                continue;
            }

            // SLIDE
            if (n.type === 3) {
                if (Math.abs(tx - targetX) < SLIDE_X_WIN && dt <= GD_WIN) {
                    if (type === 'touchstart' || type === 'mousedown' || type === 'touchmove') {
                        playSFX('SLIDE'); n.hit=true; 
                        addScore(1.0); stats.p++; triggerJudge("PERFECT", "var(--c-perfect)");
                        hitEffects.push({x: targetX, y: height*JUDGE_LINE_PCT, life: 1, color: n.songColor});
                        combo++; spawnParticles(targetX, height*JUDGE_LINE_PCT, n.songColor, 8); updateHUD();
                    }
                }
            } 
            // FLICK
            else if (n.type >= 4 && n.type <= 8) {
                 if (Math.abs(tx - targetX) < NORMAL_X_WIN && dt <= GD_WIN) {
                     let triggered = false;
                     const flickThresh = width * 0.02;
                     if (type === 'touchmove' || type === 'touchend' || type === 'mouseup') {
                         if (n.type === 4 && deltaX < -flickThresh) triggered = true; 
                         else if (n.type === 5 && deltaX > flickThresh) triggered = true; 
                         else if (n.type === 7 && deltaY < -flickThresh) triggered = true; 
                         else if (n.type === 8 && deltaY > flickThresh) triggered = true; 
                     }
                     
                     if (triggered) {
                        playSFX('FLICK'); n.hit=true; 
                        addScore(1.0); stats.p++; triggerJudge("PERFECT", "var(--c-perfect)");
                        hitEffects.push({x: targetX, y: height*JUDGE_LINE_PCT, life: 1, color: n.songColor});
                        combo++; spawnParticles(targetX, height*JUDGE_LINE_PCT, n.songColor, 20); updateHUD();
                        break; 
                     }
                 }
            }
            // TAP
            else {
                if (Math.abs(tx - targetX) < NORMAL_X_WIN && dt <= GD_WIN) {
                    if (type === 'touchstart' || type === 'mousedown') {
                         playSFX('TAP'); n.hit=true; 
                         if (dt < P_WIN) { addScore(1.0); stats.p++; triggerJudge("PERFECT", "var(--c-perfect)"); }
                         else if (dt < GR_WIN) { addScore(0.8); stats.gr++; triggerJudge("GREAT", "var(--c-great)"); }
                         else { addScore(0.5); stats.gd++; triggerJudge("GOOD", "var(--c-good)"); }
                         hitEffects.push({x: targetX, y: height*JUDGE_LINE_PCT, life: 1, color: n.songColor});
                         combo++; spawnParticles(targetX, height*JUDGE_LINE_PCT, n.songColor, 15); updateHUD();
                         break;
                    }
                }
            }
        }
    });

    if(type === 'touchend' || type === 'mouseup') {
        touches.forEach(t => {
            const endedId = t.identifier !== undefined ? t.identifier : 'mouse';
            activeNotes.forEach(n => {
                if(n.holding && n.holdingTouchId === endedId) {
                    if(time >= n.t + n.d - GD_WIN) {
                         if(!n.hit) {
                            n.hit=true; n.missed=true; addScore(1.0); combo++; triggerJudge("PERFECT", "var(--c-perfect)"); updateHUD(); playSFX('HOLD_END');
                         }
                    } else {
                        n.holding=false; n.missed=true; combo=0; stats.m++; triggerJudge("MISS", "var(--c-miss)"); updateHUD();
                    }
                    n.holdingTouchId = null; 
                }
            });
        });
    }
}

function spawnParticles(x, y, c, num) { for(let i=0;i<num;i++) particles.push({x:x, y:y, vx:(Math.random()-0.5)*15, vy:(Math.random()-1)*15, life:1, color:c}); }
function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.5; p.life-=0.04;
        if(p.life<=0) particles.splice(i,1);
        else { ctx.globalAlpha=p.life; ctx.fillStyle=p.color; ctx.fillRect(p.x, p.y, 5, 5); }
    }
    ctx.globalAlpha=1;
}
function triggerJudge(txt, colorVar) {
    const el = document.getElementById('judge'); el.innerText=txt; el.style.color = colorVar;
    el.classList.remove('anim-judge'); void el.offsetWidth; el.classList.add('anim-judge');
}
function updateHUD() { 
    document.getElementById('score').innerText=score.toString().padStart(6,'0'); 
    const cEl = document.getElementById('combo');
    if(combo > 1) { cEl.innerText = combo; cEl.classList.remove('bump'); void cEl.offsetWidth; cEl.classList.add('bump'); } else { cEl.innerText = ""; }
    if(combo > maxCombo) maxCombo = combo;
}
function pauseGame() { 
    if(gameState==="PLAY" || gameState==="COUNTDOWN" || gameState==="HOME"){
        pausedFrom = gameState;
        if(gameState === "COUNTDOWN") {
            clearInterval(countdownTimer);
            pausedFrom = "PLAY";
        }
        pausedTime = document.getElementById('bgm').currentTime;
        gameState="PAUSE"; 
        document.getElementById('bgm').pause(); 
        document.getElementById('screen-pause').classList.remove('hidden');
    }
}
function resumeGame() { 
    document.getElementById('screen-pause').classList.add('hidden');
    if (pausedFrom === "HOME") {
        gameState = "HOME";
        startPreview();
        return;
    }
    
    // 1 second wait on current frame
    gameState = "RESUME_WAIT";
    
    setTimeout(() => {
        gameState = "PLAY";
        const bgm = document.getElementById('bgm');
        // Recalculate start time based on current audio time to ensure sync
        gameStartTime = performance.now() - (bgm.currentTime + AUDIO_DELAY) * 1000;
        bgm.play().catch(()=>{});
    }, 1000);
}
function quitGame() {
    gameState="HOME"; stopPreview(); document.getElementById('bgm').pause(); isAudioPlaying = false;
    document.getElementById('screen-hud').classList.add('hidden');
    document.getElementById('screen-pause').classList.add('hidden');
    document.getElementById('screen-result').classList.add('hidden');
    document.getElementById('screen-home').classList.remove('hidden'); document.getElementById('screen-home').classList.add('active-ui');
    document.getElementById('master-layer').style.opacity = 0;
    initCarousel(); updateHomeUI();
}
function showResult() {
    gameState="RESULT";
    document.getElementById('screen-hud').classList.add('hidden');
    document.getElementById('screen-result').classList.remove('hidden');
    document.getElementById('res-score').innerText=score; document.getElementById('res-combo').innerText=maxCombo;
    document.getElementById('stat-p').innerText=stats.p; document.getElementById('stat-gr').innerText=stats.gr;
    document.getElementById('stat-gd').innerText=stats.gd; document.getElementById('stat-m').innerText=stats.m;
    
    let r = "F";
    if(score >= 1000000) r="SS";
    else if(score >= 950000) r="S";
    else if(score >= 900000) r="A";
    else if(score >= 800000) r="B";
    else if(score >= 700000) r="C"; 
    
    const rankEl = document.getElementById('res-rank');
    rankEl.innerText = r;
    rankEl.className = ""; 
    document.getElementById('master-layer').style.opacity = 0;
    if(r === "SS") rankEl.classList.add("rank-SS");
    
    saveHighScore(SONGS[currentSongIdx].id, currentDiff, score, r);
}
</script>
</body>
</html>